# input

```json
{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"title": "DynamicConfig",
	"type": "object",
	"description": "Configuration with dynamic field names following specific patterns",
	"patternProperties": {
		"^S_": {
			"type": "string",
			"description": "String fields must start with S_ prefix (e.g., S_name, S_description)"
		},
		"^N_": {
			"type": "number",
			"description": "Number fields must start with N_ prefix (e.g., N_count, N_ratio)"
		}
	},
	"additionalProperties": false
}
```

---

# expected-output

```go
// Code generated by schema2go. DO NOT EDIT.
// üèóÔ∏è Generated from JSON Schema

package models

import (
    "encoding/json"
    "gitlab.com/tozd/go/errors"
)

// DynamicConfig represents a configuration with dynamic field names following specific patterns
type DynamicConfig struct {
    // String fields must start with S_ prefix (e.g., S_name, S_description)
    StringFields_Pattern map[string]string `json:"-"`

    // Number fields must start with N_ prefix (e.g., N_count, N_ratio)
    NumberFields_Pattern map[string]float64 `json:"-"`
}

func (d *DynamicConfig) UnmarshalJSON(data []byte) error {
    // TODO: Implement pattern-based unmarshaling
    // 1. Parse raw JSON into map[string]interface{}
    // 2. For each key-value pair:
    //    - If key starts with S_, validate value is string and add to StringFields
    //    - If key starts with N_, validate value is number and add to NumberFields
    //    - Otherwise, return error for invalid pattern
    return nil
}

func (d DynamicConfig) MarshalJSON() ([]byte, error) {
    // TODO: Implement pattern-based marshaling
    // 1. Create output map combining both field maps
    // 2. Validate all keys follow required patterns
    // 3. Marshal to JSON
    return nil, nil
}

func (d *DynamicConfig) Validate() error {
    // Validate string field patterns
    for key := range d.StringFields_Pattern {
        if !strings.HasPrefix(key, "S_") {
            return errors.Errorf("invalid string field key %q: must start with S_", key)
        }
    }

    // Validate number field patterns
    for key := range d.NumberFields_Pattern {
        if !strings.HasPrefix(key, "N_") {
            return errors.Errorf("invalid number field key %q: must start with N_", key)
        }
    }
    return nil
}
```
