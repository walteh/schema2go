// Code generated by github.com/walteh/schema2go, DO NOT EDIT.

package test

import (
	"encoding/json"
	"fmt"
	"time"
)

// Root represents the root schema
type Root struct {
	// A notification that combines base fields with content that can be either text or action buttons
	Notification Notification `json:"notification"`
}

// ContentType represents the type of notification content
type ContentType string

const (
	ContentTypeText   ContentType = "text"
	ContentTypeAction ContentType = "action"
)

// Notification represents a notification with base fields and specialized content
type Notification struct {
	// Base fields (from allOf)
	ID        string    `json:"id"`
	Timestamp time.Time `json:"timestamp"`

	// Content (oneOf)
	Content NotificationContent `json:"content"`
}

// NotificationContent represents either text or action content
type NotificationContent struct {
	Type ContentType `json:"type"`

	// Text content
	Message *string `json:"message,omitempty"`

	// Action content
	Buttons []Button `json:"buttons,omitempty"`
}

// Button represents a button that can be either a URL or an action
type Button struct {
	// Common fields
	Label string `json:"label"`

	// URL button fields
	URL *string `json:"url,omitempty"`

	// Action button fields
	Action *string `json:"action,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler for NotificationContent
func (c *NotificationContent) UnmarshalJSON(data []byte) error {
	// First unmarshal the type field
	var typeContainer struct {
		Type ContentType `json:"type"`
	}
	if err := json.Unmarshal(data, &typeContainer); err != nil {
		return fmt.Errorf("invalid content type: %w", err)
	}

	// Then unmarshal the full object based on the type
	switch typeContainer.Type {
	case ContentTypeText:
		var text struct {
			Type    ContentType `json:"type"`
			Message string      `json:"message"`
		}
		if err := json.Unmarshal(data, &text); err != nil {
			return fmt.Errorf("invalid text content: %w", err)
		}
		c.Type = text.Type
		c.Message = &text.Message

	case ContentTypeAction:
		var action struct {
			Type    ContentType `json:"type"`
			Buttons []Button    `json:"buttons"`
		}
		if err := json.Unmarshal(data, &action); err != nil {
			return fmt.Errorf("invalid action content: %w", err)
		}
		if len(action.Buttons) == 0 {
			return fmt.Errorf("action content requires at least one button")
		}
		c.Type = action.Type
		c.Buttons = action.Buttons

	default:
		return fmt.Errorf("unknown content type: %s", typeContainer.Type)
	}

	return nil
}

// MarshalJSON implements json.Marshaler for NotificationContent
func (c NotificationContent) MarshalJSON() ([]byte, error) {
	switch c.Type {
	case ContentTypeText:
		if c.Message == nil {
			return nil, fmt.Errorf("text content requires message")
		}
		return json.Marshal(struct {
			Type    ContentType `json:"type"`
			Message string      `json:"message"`
		}{
			Type:    c.Type,
			Message: *c.Message,
		})

	case ContentTypeAction:
		if len(c.Buttons) == 0 {
			return nil, fmt.Errorf("action content requires at least one button")
		}
		return json.Marshal(struct {
			Type    ContentType `json:"type"`
			Buttons []Button    `json:"buttons"`
		}{
			Type:    c.Type,
			Buttons: c.Buttons,
		})

	default:
		return nil, fmt.Errorf("unknown content type: %s", c.Type)
	}
}

// UnmarshalJSON implements json.Unmarshaler for Button
func (b *Button) UnmarshalJSON(data []byte) error {
	// Try URL button
	var urlButton struct {
		Label string `json:"label"`
		URL   string `json:"url"`
	}
	if err := json.Unmarshal(data, &urlButton); err == nil {
		b.Label = urlButton.Label
		b.URL = &urlButton.URL
		return nil
	}

	// Try action button
	var actionButton struct {
		Label  string `json:"label"`
		Action string `json:"action"`
	}
	if err := json.Unmarshal(data, &actionButton); err == nil {
		b.Label = actionButton.Label
		b.Action = &actionButton.Action
		return nil
	}

	return fmt.Errorf("button must have either url or action")
}

// MarshalJSON implements json.Marshaler for Button
func (b Button) MarshalJSON() ([]byte, error) {
	if b.URL != nil {
		return json.Marshal(struct {
			Label string `json:"label"`
			URL   string `json:"url"`
		}{
			Label: b.Label,
			URL:   *b.URL,
		})
	}

	if b.Action != nil {
		return json.Marshal(struct {
			Label  string `json:"label"`
			Action string `json:"action"`
		}{
			Label:  b.Label,
			Action: *b.Action,
		})
	}

	return nil, fmt.Errorf("button must have either url or action")
} 