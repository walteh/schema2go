// Code generated by github.com/walteh/schema2go, DO NOT EDIT.

package test

import (
	"encoding/json"
	"fmt"
)

// Root represents the root schema
type Root struct {
	// Payment information - must be exactly one of the specified types
	Payment Payment `json:"payment"`
}

// PaymentType represents the type of payment
type PaymentType string

const (
	PaymentTypeCreditCard   PaymentType = "credit_card"
	PaymentTypeBankTransfer PaymentType = "bank_transfer"
	PaymentTypeCrypto       PaymentType = "crypto"
)

// CryptoCurrency represents supported cryptocurrencies
type CryptoCurrency string

const (
	CryptoCurrencyBTC CryptoCurrency = "BTC"
	CryptoCurrencyETH CryptoCurrency = "ETH"
)

// Payment represents a payment method - must be exactly one of the specified types
type Payment struct {
	Type PaymentType `json:"type"`

	// Credit Card fields
	CardNumber *string `json:"card_number,omitempty"`
	Expiry     *string `json:"expiry,omitempty"`
	CVV        *string `json:"cvv,omitempty"`

	// Bank Transfer fields
	AccountNumber  *string `json:"account_number,omitempty"`
	RoutingNumber *string `json:"routing_number,omitempty"`

	// Crypto fields
	WalletAddress *string        `json:"wallet_address,omitempty"`
	Currency      *CryptoCurrency `json:"currency,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler
func (p *Payment) UnmarshalJSON(data []byte) error {
	// First unmarshal the type field to determine which payment type we're dealing with
	var typeContainer struct {
		Type PaymentType `json:"type"`
	}
	if err := json.Unmarshal(data, &typeContainer); err != nil {
		return fmt.Errorf("invalid payment type: %w", err)
	}

	// Then unmarshal the full object based on the type
	switch typeContainer.Type {
	case PaymentTypeCreditCard:
		var cc struct {
			Type       PaymentType `json:"type"`
			CardNumber string      `json:"card_number"`
			Expiry     string      `json:"expiry"`
			CVV        string      `json:"cvv"`
		}
		if err := json.Unmarshal(data, &cc); err != nil {
			return fmt.Errorf("invalid credit card payment: %w", err)
		}
		p.Type = cc.Type
		p.CardNumber = &cc.CardNumber
		p.Expiry = &cc.Expiry
		p.CVV = &cc.CVV

	case PaymentTypeBankTransfer:
		var bt struct {
			Type          PaymentType `json:"type"`
			AccountNumber string      `json:"account_number"`
			RoutingNumber string      `json:"routing_number"`
		}
		if err := json.Unmarshal(data, &bt); err != nil {
			return fmt.Errorf("invalid bank transfer payment: %w", err)
		}
		p.Type = bt.Type
		p.AccountNumber = &bt.AccountNumber
		p.RoutingNumber = &bt.RoutingNumber

	case PaymentTypeCrypto:
		var crypto struct {
			Type          PaymentType    `json:"type"`
			WalletAddress string         `json:"wallet_address"`
			Currency      CryptoCurrency `json:"currency"`
		}
		if err := json.Unmarshal(data, &crypto); err != nil {
			return fmt.Errorf("invalid crypto payment: %w", err)
		}
		p.Type = crypto.Type
		p.WalletAddress = &crypto.WalletAddress
		p.Currency = &crypto.Currency

	default:
		return fmt.Errorf("unknown payment type: %s", typeContainer.Type)
	}

	return nil
}

// MarshalJSON implements json.Marshaler
func (p Payment) MarshalJSON() ([]byte, error) {
	switch p.Type {
	case PaymentTypeCreditCard:
		if p.CardNumber == nil || p.Expiry == nil || p.CVV == nil {
			return nil, fmt.Errorf("credit card payment requires card_number, expiry, and cvv")
		}
		return json.Marshal(struct {
			Type       PaymentType `json:"type"`
			CardNumber string      `json:"card_number"`
			Expiry     string      `json:"expiry"`
			CVV        string      `json:"cvv"`
		}{
			Type:       p.Type,
			CardNumber: *p.CardNumber,
			Expiry:     *p.Expiry,
			CVV:        *p.CVV,
		})

	case PaymentTypeBankTransfer:
		if p.AccountNumber == nil || p.RoutingNumber == nil {
			return nil, fmt.Errorf("bank transfer payment requires account_number and routing_number")
		}
		return json.Marshal(struct {
			Type          PaymentType `json:"type"`
			AccountNumber string      `json:"account_number"`
			RoutingNumber string      `json:"routing_number"`
		}{
			Type:          p.Type,
			AccountNumber: *p.AccountNumber,
			RoutingNumber: *p.RoutingNumber,
		})

	case PaymentTypeCrypto:
		if p.WalletAddress == nil || p.Currency == nil {
			return nil, fmt.Errorf("crypto payment requires wallet_address and currency")
		}
		return json.Marshal(struct {
			Type          PaymentType    `json:"type"`
			WalletAddress string         `json:"wallet_address"`
			Currency      CryptoCurrency `json:"currency"`
		}{
			Type:          p.Type,
			WalletAddress: *p.WalletAddress,
			Currency:      *p.Currency,
		})

	default:
		return nil, fmt.Errorf("unknown payment type: %s", p.Type)
	}
} 